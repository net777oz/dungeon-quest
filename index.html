<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Little Explorer's Mysterious Dungeon</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@400;700&display=swap');

        :root {
            --bg-color: #1a1a2e;
            --panel-bg: #16213e;
            --accent-color: #e94560;
            --text-color: #ecf0f1;
            --highlight: #f39c12;
            --grid-line: #2c3e50;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Outfit', sans-serif;
            overflow: hidden;
            display: flex;
            height: 100vh;
        }

        #game-container {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        canvas {
            image-rendering: pixelated;
            max-width: 100%;
            max-height: 100%;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #ui-panel {
            width: 320px;
            background-color: var(--panel-bg);
            border-left: 2px solid #333;
            padding: 20px;
            display: flex;
            flex-direction: column;
            box-shadow: -5px 0 15px rgba(0,0,0,0.3);
            z-index: 10;
        }

        h1, h2, h3 {
            margin: 0 0 15px 0;
            color: var(--accent-color);
            text-shadow: 2px 2px 0px rgba(0,0,0,0.5);
        }

        .section {
            margin-bottom: 25px;
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.05);
        }

        /* Controls Hints */
        .controls-hint {
            font-size: 0.9em;
            color: #bdc3c7;
            line-height: 1.6;
        }
        .btn-icon {
            display: inline-block;
            background: #eee;
            color: #333;
            border-radius: 4px;
            padding: 0 6px;
            font-weight: bold;
            font-size: 0.8em;
            box-shadow: 0 2px 0 #999;
        }

        /* Editor UI */
        #editor-ui { display: none; }
        .palette-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        .palette-item {
            aspect-ratio: 1;
            background: #333;
            border: 2px solid #555;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .palette-item.selected {
            border-color: var(--accent-color);
            background: rgba(233, 69, 96, 0.2);
            box-shadow: 0 0 10px var(--accent-color);
            transform: scale(1.1);
        }

        /* Game UI */
        #game-ui { display: none; }
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        .inv-slot {
            aspect-ratio: 1;
            background: rgba(0,0,0,0.4);
            border: 2px solid #444;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
        }
        .inv-slot.has-item {
            border-color: var(--highlight);
            background: rgba(243, 156, 18, 0.2);
            box-shadow: 0 0 8px var(--highlight);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* Mini-map */
        #minimap-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0,0,0,0.8);
            border: 2px solid var(--accent-color);
            border-radius: 50%;
            overflow: hidden;
            display: none; /* Hidden by default */
            z-index: 5;
        }
        #minimap {
            width: 100%;
            height: 100%;
        }

        /* Notifications */
        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 4px 10px rgba(0,0,0,0.8);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            text-align: center;
            width: 100%;
        }

        /* Animations */
        @keyframes popIn {
            0% { transform: scale(0); }
            100% { transform: scale(1); }
        }
        
        .mode-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
        }
        .mode-editor { background: #3498db; color: white; }
        .mode-play { background: #e74c3c; color: white; }

        input[type=range] { width: 100%; }
        
        button {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
            width: 100%;
            font-size: 1rem;
        }
        button:hover { filter: brightness(1.1); }
        button:active { transform: translateY(2px); }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="screen" width="640" height="480"></canvas>
    <div id="minimap-container"><canvas id="minimap"></canvas></div>
    <div id="message-overlay"></div>
</div>

<div id="ui-panel">
    <h1>Dungeon Quest</h1>
    <div id="mode-display"><span class="mode-badge mode-editor">Editor Mode</span></div>

    <!-- Stats / Global Info -->
    <div class="section">
        <div class="controls-hint">
            <p><strong>üéÆ Gamepad</strong></p>
            <p><span class="btn-icon">D-Pad</span> Move / Cursor</p>
            <p><span class="btn-icon">A</span> Interact / Place</p>
            <p><span class="btn-icon">B</span> Palette / Back</p>
            <p><span class="btn-icon">Start</span> Play / Edit</p>
        </div>
    </div>

    <!-- Editor Specific UI -->
    <div id="editor-ui">
        <h2>üèóÔ∏è Map Builder</h2>
        <div class="section">
            <label>Map Size: <span id="size-label">20x20</span></label>
            <input type="range" id="size-slider" min="10" max="60" step="10" value="20">
            <button id="reset-map-btn">New Map (Reset)</button>
        </div>
        
        <div class="section">
            <h3>Palette</h3>
            <div class="palette-grid" id="palette-container">
                <!-- Javascript will populate this -->
            </div>
        </div>

        <div class="section"> 
             <button id="save-btn">üíæ Save Map</button>
             <button id="load-btn">üìÇ Load Map</button>
             <button id="play-btn" style="background:#2ecc71">‚ñ∂Ô∏è PLAY GAME</button>
        </div>
    </div>

    <!-- Game Specific UI -->
    <div id="game-ui">
        <h2>üéí Backpack</h2>
        <div class="inventory-grid">
            <div id="slot-map" class="inv-slot" title="Map">üó∫Ô∏è</div>
            <div id="slot-hammer" class="inv-slot" title="Hammer">üî®</div>
            <div id="slot-key1" class="inv-slot" title="Key 1">üîë1</div>
            <div id="slot-key2" class="inv-slot" title="Key 2">üîë2</div>
            <div id="slot-key3" class="inv-slot" title="Key 3">üîë3</div>
            <div id="slot-treasure" class="inv-slot" title="Treasures">üíé <span id="treasure-count">0</span></div>
        </div>
        <div style="margin-top: 30px;">
            <button id="edit-btn" style="background:#3498db">‚úèÔ∏è BACK TO EDIT</button>
        </div>
    </div>
</div>

<script>
/**
 * DUNGEON QUEST - SINGLE FILE PROTOTYPE
 * Includes: Map Editor, Raycasting Engine, Gamepad Logic, Game State
 */

// --- Constants & Config ---
const TILES = {
    EMPTY: 0,
    WALL: 1,
    SECRET_WALL: 2, // Destructible
    START: 3,
    TREASURE: 4,
    HAMMER: 5,
    MAP: 6,
    KEY_1: 7,
    KEY_2: 8,
    KEY_3: 9,
    DOOR_1: 10, // Needs KEY_1
    DOOR_2: 11, // Needs KEY_2
    DOOR_3: 12  // Needs KEY_3
};

// Visual representation for Editor & Mini-map
const TILE_COLORS = {
    [TILES.EMPTY]: "#2c3e50", // Path color
    [TILES.WALL]: "#95a5a6",
    [TILES.SECRET_WALL]: "#7f8c8d", // Looks distinct in editor, same as wall in game
    [TILES.START]: "#2ecc71",
    [TILES.TREASURE]: "#f1c40f",
    [TILES.HAMMER]: "#e67e22",
    [TILES.MAP]: "#3498db",
    [TILES.KEY_1]: "#e74c3c", [TILES.KEY_2]: "#e74c3c", [TILES.KEY_3]: "#e74c3c",
    [TILES.DOOR_1]: "#8e44ad", [TILES.DOOR_2]: "#8e44ad", [TILES.DOOR_3]: "#8e44ad"
};

const TILE_ICONS = {
    [TILES.EMPTY]: "‚¨õ",
    [TILES.WALL]: "üß±",
    [TILES.SECRET_WALL]: "ü§´",
    [TILES.START]: "üö©",
    [TILES.TREASURE]: "üíé",
    [TILES.HAMMER]: "üî®",
    [TILES.MAP]: "üó∫Ô∏è",
    [TILES.KEY_1]: "üîë1", [TILES.KEY_2]: "üîë2", [TILES.KEY_3]: "üîë3",
    [TILES.DOOR_1]: "üö™1", [TILES.DOOR_2]: "üö™2", [TILES.DOOR_3]: "üö™3"
};

// 1st Person Texture Colors (Pastel / Bright for kid)
const WALL_COLORS = {
    [TILES.WALL]: { r:100, g:149, b:237 }, // Cornflower Blue
    [TILES.SECRET_WALL]: { r:100, g:149, b:237 }, // SAME AS WALL!
    [TILES.DOOR_1]: { r:155, g:89, b:182 }, // Purple
    [TILES.DOOR_2]: { r:155, g:89, b:182 },
    [TILES.DOOR_3]: { r:155, g:89, b:182 }
};

// --- State Management ---
const AppState = {
    mode: 'EDITOR', // 'EDITOR' or 'PLAY'
    mapSize: 20,
    map: [], // 2D array
    
    // Editor State
    editorCursor: { x: 1, y: 1 },
    selectedTile: TILES.EMPTY,
    
    // Game State
    player: { x: 1.5, y: 1.5, dir: 0, rot: 0, speed: 0 },
    inventory: {
        hammer: false,
        map: false,
        keys: [false, false, false], // 1, 2, 3
        treasures: 0,
        totalTreasures: 0
    },
    
    // System
    lastTime: 0,
    keysPressed: {},
    gamepadIndex: null
};

// --- Initialization ---
function init() {
    createEmptyMap(AppState.mapSize);
    setupEvents();
    buildPalette();
    requestAnimationFrame(gameLoop);
}

function createEmptyMap(size) {
    AppState.mapSize = size;
    AppState.map = [];
    for(let y=0; y<size; y++) {
        let row = [];
        for(let x=0; x<size; x++) {
            row.push(TILES.WALL); // Fill with walls
        }
        AppState.map.push(row);
    }
    // Set a default start if new
    AppState.map[1][1] = TILES.EMPTY; 
}

// --- Input Handling ---
function setupEvents() {
    window.addEventListener('keydown', e => AppState.keysPressed[e.code] = true);
    window.addEventListener('keyup', e => AppState.keysPressed[e.code] = false);
    
    window.addEventListener("gamepadconnected", (e) => {
        console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
        e.gamepad.index, e.gamepad.id, e.gamepad.buttons.length, e.gamepad.axes.length);
        AppState.gamepadIndex = e.gamepad.index;
        showNotification("üéÆ Gamepad Connected!");
    });

    // UI Buttons
    document.getElementById('size-slider').addEventListener('input', (e) => {
        document.getElementById('size-label').innerText = `${e.target.value}x${e.target.value}`;
    });
    
    document.getElementById('reset-map-btn').addEventListener('click', () => {
        if(confirm("Clear entire map?")) {
            createEmptyMap(parseInt(document.getElementById('size-slider').value));
        }
    });

    document.getElementById('play-btn').addEventListener('click', enterPlayMode);
    document.getElementById('edit-btn').addEventListener('click', enterEditorMode);
    
    document.getElementById('save-btn').addEventListener('click', () => {
        localStorage.setItem('dungeonMap', JSON.stringify(AppState.map));
        showNotification("Map Saved! üíæ");
    });
    
    document.getElementById('load-btn').addEventListener('click', () => {
        const data = localStorage.getItem('dungeonMap');
        if(data) {
            AppState.map = JSON.parse(data);
            AppState.mapSize = AppState.map.length;
            showNotification("Map Loaded! üìÇ");
        }
    });
}

function buildPalette() {
    const container = document.getElementById('palette-container');
    container.innerHTML = '';
    
    Object.keys(TILES).forEach(key => {
        const val = TILES[key];
        const div = document.createElement('div');
        div.className = 'palette-item';
        div.innerText = TILE_ICONS[val];
        div.title = key;
        div.onclick = () => selectPaletteItem(val, div);
        if(val === TILES.EMPTY) div.classList.add('selected');
        container.appendChild(div);
    });
}

function selectPaletteItem(val, element) {
    AppState.selectedTile = val;
    document.querySelectorAll('.palette-item').forEach(el => el.classList.remove('selected'));
    element.classList.add('selected');
}

// --- Main Loop ---
function gameLoop(timestamp) {
    const dt = (timestamp - AppState.lastTime) / 1000;
    AppState.lastTime = timestamp;

    handleInput(dt);
    
    if(AppState.mode === 'EDITOR') {
        renderEditor();
    } else {
        updateGame(dt);
        renderGame();
    }

    requestAnimationFrame(gameLoop);
}

// --- Input Logic (Gamepad + Keyboard) ---
// Button Mappings (Standard): 0=A, 1=B, 12=Up, 13=Down, 14=Left, 15=Right
function handleInput(dt) {
    const gp = AppState.gamepadIndex !== null ? navigator.getGamepads()[AppState.gamepadIndex] : null;

    // Helper for "Just Pressed"
    const isPressed = (key, btnIdx) => {
        return (AppState.keysPressed[key]) || (gp && gp.buttons[btnIdx] && gp.buttons[btnIdx].pressed);
    };

    // D-PAD / Axes
    let dx = 0, dy = 0;
    if(AppState.keysPressed['ArrowUp']) dy = -1;
    if(AppState.keysPressed['ArrowDown']) dy = 1;
    if(AppState.keysPressed['ArrowLeft']) dx = -1;
    if(AppState.keysPressed['ArrowRight']) dx = 1;

    if(gp) {
        if(gp.buttons[12].pressed) dy = -1;
        if(gp.buttons[13].pressed) dy = 1;
        if(gp.buttons[14].pressed) dx = -1;
        if(gp.buttons[15].pressed) dx = 1;
        // Analog stick support
        if(Math.abs(gp.axes[0]) > 0.2) dx = gp.axes[0];
        if(Math.abs(gp.axes[1]) > 0.2) dy = gp.axes[1];
    }

    // Mode Specific Handling
    if(AppState.mode === 'EDITOR') {
        handleEditorInput(dx, dy, gp);
    } else {
        handleGameInput(dx, dy, dt, gp);
    }
}

// --- EDITOR LOGIC ---
let movementTimer = 0;
let actionCooldown = false;

function handleEditorInput(dx, dy, gp) {
    // Cursor Movement (throttled)
    movementTimer += 1;
    if(movementTimer > 5) {
        if(Math.abs(dx) > 0.5) AppState.editorCursor.x += Math.sign(dx);
        if(Math.abs(dy) > 0.5) AppState.editorCursor.y += Math.sign(dy);
        
        // Clamp
        AppState.editorCursor.x = Math.max(0, Math.min(AppState.mapSize-1, AppState.editorCursor.x));
        AppState.editorCursor.y = Math.max(0, Math.min(AppState.mapSize-1, AppState.editorCursor.y));
        
        if(Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) movementTimer = 0;
    }

    // Action: A Button (Place Tile)
    const btnA = (gp && gp.buttons[0].pressed) || AppState.keysPressed['Space'];
    
    if(btnA && !actionCooldown) {
        placeTileAtCursor();
        actionCooldown = true;
        setTimeout(() => actionCooldown = false, 200);
    }
}

function placeTileAtCursor() {
    const {x, y} = AppState.editorCursor;
    const tileToPlace = AppState.selectedTile;
    const currentTile = AppState.map[y][x];

    // RULE: If placing PATH (0), just do it.
    if(tileToPlace === TILES.EMPTY) {
        AppState.map[y][x] = tileToPlace;
        return;
    }

    // RULE: If placing ANYTHING ELSE, must be on PATH (0) or replacing existing item
    // Cannot place items on WALL (1) directly.
    const isPath = currentTile === TILES.EMPTY;
    const isItem = currentTile > TILES.WALL; 
    
    if(isPath || isItem || currentTile === TILES.SECRET_WALL) {
        AppState.map[y][x] = tileToPlace;
    } else {
        // trying to place on wall
        showNotification("Must dig a path first! ‚õèÔ∏è");
    }
}

function renderEditor() {
    const cvs = document.getElementById('screen');
    const ctx = cvs.getContext('2d');
    const w = cvs.width;
    const h = cvs.height;
    
    // Clear
    ctx.fillStyle = '#111';
    ctx.fillRect(0,0,w,h);

    // Calculate Grid Scaling
    const cellSize = Math.min(w, h) / AppState.mapSize;
    const offsetX = (w - (cellSize * AppState.mapSize)) / 2;
    const offsetY = (h - (cellSize * AppState.mapSize)) / 2;

    // Draw Map
    for(let y=0; y<AppState.mapSize; y++) {
        for(let x=0; x<AppState.mapSize; x++) {
            const tile = AppState.map[y][x];
            ctx.fillStyle = TILE_COLORS[tile] || '#000';
            ctx.fillRect(offsetX + x*cellSize, offsetY + y*cellSize, cellSize-1, cellSize-1);
            
            // Icon
            if(TILE_ICONS[tile] && tile !== TILES.EMPTY && tile !== TILES.WALL) {
                 ctx.font = `${cellSize/1.5}px Arial`;
                 ctx.textAlign = 'center';
                 ctx.textBaseline = 'middle';
                 ctx.fillText(TILE_ICONS[tile], offsetX + x*cellSize + cellSize/2, offsetY + y*cellSize + cellSize/2);
            }
        }
    }

    // Draw Cursor
    const cx = AppState.editorCursor.x;
    const cy = AppState.editorCursor.y;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3;
    ctx.strokeRect(offsetX + cx*cellSize, offsetY + cy*cellSize, cellSize, cellSize);
    
    // Cursor Blink
    if(Math.floor(Date.now() / 300) % 2 === 0) {
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillRect(offsetX + cx*cellSize, offsetY + cy*cellSize, cellSize, cellSize);
    }
}


// --- PLAY MODE Logic ---

function enterPlayMode() {
    // Validate Start Position
    let startFound = false;
    let treasures = 0;
    
    for(let y=0; y<AppState.mapSize; y++) {
        for(let x=0; x<AppState.mapSize; x++) {
            if(AppState.map[y][x] === TILES.START) {
                AppState.player.x = x + 0.5;
                AppState.player.y = y + 0.5;
                startFound = true;
            }
            if(AppState.map[y][x] === TILES.TREASURE) treasures++;
        }
    }
    
    if(!startFound) {
        showNotification("No Start Point (üö©) Found!");
        return;
    }

    AppState.mode = 'PLAY';
    AppState.inventory = { hammer: false, map: false, keys: [0,0,0], treasures: 0, totalTreasures: treasures };
    
    // UI Update
    document.getElementById('editor-ui').style.display = 'none';
    document.getElementById('game-ui').style.display = 'block';
    document.querySelector('.mode-badge').className = 'mode-badge mode-play';
    document.querySelector('.mode-badge').innerText = 'Explorer Mode';
    updateInventoryUI();
    
    showNotification("Find all the Treasures! üíé");
}

function enterEditorMode() {
    AppState.mode = 'EDITOR';
    document.getElementById('editor-ui').style.display = 'block';
    document.getElementById('game-ui').style.display = 'none';
    document.getElementById('minimap-container').style.display = 'none'; // Hide Map
    document.querySelector('.mode-badge').className = 'mode-badge mode-editor';
    document.querySelector('.mode-badge').innerText = 'Editor Mode';
}

function handleGameInput(dx, dy, dt, gp) {
    const speed = 3.0 * dt;
    const rotSpeed = 2.5 * dt;

    // Rotation (Left/Right)
    if(dx !== 0) {
        AppState.player.dir += dx * rotSpeed;
    }

    // Movement (Up/Down) - relative to direction
    if(dy !== 0) {
        const moveStep = -dy * speed; // -dy because up is negative in axes usually
        
        const newX = AppState.player.x + Math.cos(AppState.player.dir) * moveStep;
        const newY = AppState.player.y + Math.sin(AppState.player.dir) * moveStep;

        // Collision Check (Simple)
        if(!isSolid(newX, AppState.player.y)) AppState.player.x = newX;
        if(!isSolid(AppState.player.x, newY)) AppState.player.y = newY;
    }
    
    // Pickup / Interaction Logic
    checkTileInteraction();

    // Interaction Button (A)
    const btnA = (gp && gp.buttons[0].pressed) || AppState.keysPressed['Space'] || AppState.keysPressed['Enter'];
    
    if(btnA && !actionCooldown) {
        performInteraction();
        actionCooldown = true;
        setTimeout(() => actionCooldown = false, 300);
    }
}

function isSolid(x, y) {
    const tx = Math.floor(x);
    const ty = Math.floor(y);
    if(tx < 0 || tx >= AppState.mapSize || ty < 0 || ty >= AppState.mapSize) return true;
    
    const tile = AppState.map[ty][tx];
    // Walls, Secret Walls, Doors are Solid
    return tile === TILES.WALL || tile === TILES.SECRET_WALL || (tile >= TILES.DOOR_1 && tile <= TILES.DOOR_3);
}

function checkTileInteraction() {
    const px = Math.floor(AppState.player.x);
    const py = Math.floor(AppState.player.y);
    const tile = AppState.map[py][px];
    
    // Auto-pickup Items
    let picked = false;
    let msg = "";
    
    if(tile === TILES.EXISTS) return; // Should not happen if solid check works

    if (tile === TILES.HAMMER) {
        AppState.inventory.hammer = true;
        msg = "Got Hammer! üî®";
        picked = true;
    } else if (tile === TILES.MAP) {
        AppState.inventory.map = true;
        msg = "Got Map! üó∫Ô∏è";
        picked = true;
        document.getElementById('minimap-container').style.display = 'block';
    } else if (tile === TILES.KEY_1) {
        AppState.inventory.keys[0] = true;
        msg = "Got Key 1! üîë";
        picked = true;
    } else if (tile === TILES.KEY_2) {
        AppState.inventory.keys[1] = true;
        msg = "Got Key 2! üîë";
        picked = true;
    } else if (tile === TILES.KEY_3) {
        AppState.inventory.keys[2] = true;
        msg = "Got Key 3! üîë";
        picked = true;
    } else if (tile === TILES.TREASURE) {
        AppState.inventory.treasures++;
        msg = `Treasure! (${AppState.inventory.treasures}/${AppState.inventory.totalTreasures}) üíé`;
        picked = true;
        checkWin();
    }

    if(picked) {
        AppState.map[py][px] = TILES.EMPTY; // Remove item
        updateInventoryUI();
        showNotification(msg);
    }
}

function performInteraction() {
    // Raycast a short distance in front of player to see what we are hitting
    const dist = 1.0;
    const frontX = AppState.player.x + Math.cos(AppState.player.dir) * dist;
    const frontY = AppState.player.y + Math.sin(AppState.player.dir) * dist;
    
    const tx = Math.floor(frontX);
    const ty = Math.floor(frontY);
    
    if(tx < 0 || tx >= AppState.mapSize || ty < 0 || ty >= AppState.mapSize) return;
    
    const targetTile = AppState.map[ty][tx];
    
    // 1. Secret Wall (Destructible)
    if(targetTile === TILES.SECRET_WALL) {
        if(AppState.inventory.hammer) {
            AppState.map[ty][tx] = TILES.EMPTY;
            showNotification("SMASH! üí•");
            createParticles(tx, ty); // Visual effect
        } else {
            showNotification("Needs Hammer! üî®");
        }
    }
    // 2. Doors
    else if(targetTile >= TILES.DOOR_1 && targetTile <= TILES.DOOR_3) {
        const keyIdx = targetTile - TILES.DOOR_1; // 0, 1, 2
        if(AppState.inventory.keys[keyIdx]) {
            AppState.map[ty][tx] = TILES.EMPTY;
            showNotification("Door Opened! üö™");
        } else {
            showNotification(`Locked! Needs Key ${keyIdx+1}`);
        }
    }
}

function checkWin() {
    if(AppState.inventory.treasures >= AppState.inventory.totalTreasures) {
        setTimeout(() => {
            showNotification("üèÜ YOU WIN! üèÜ");
            // Confetti or something?
        }, 1000);
    }
}

function updateInventoryUI() {
    const inv = AppState.inventory;
    document.getElementById('slot-hammer').classList.toggle('has-item', inv.hammer);
    document.getElementById('slot-map').classList.toggle('has-item', inv.map);
    document.getElementById('slot-key1').classList.toggle('has-item', inv.keys[0]);
    document.getElementById('slot-key2').classList.toggle('has-item', inv.keys[1]);
    document.getElementById('slot-key3').classList.toggle('has-item', inv.keys[2]);
    
    // Treasure Count
    document.getElementById('treasure-count').innerText = `${inv.treasures}/${inv.totalTreasures}`;
    document.getElementById('slot-treasure').classList.toggle('has-item', inv.treasures > 0);
}


// --- RAYCASTING ENGINE ---
function renderGame() {
    const cvs = document.getElementById('screen');
    const ctx = cvs.getContext('2d');
    const w = cvs.width;
    const h = cvs.height;

    // Floor & Ceiling
    ctx.fillStyle = "#333";
    ctx.fillRect(0, 0, w, h/2);
    ctx.fillStyle = "#555";
    ctx.fillRect(0, h/2, w, h/2);

    // Raycasting
    // FOV = 60 degrees
    const fov = Math.PI / 3;
    const rayCount = w / 2; // Resolution (2px per ray)
    const stepAngle = fov / rayCount;
    
    for(let i=0; i<rayCount; i++) {
        const rayAngle = (AppState.player.dir - fov/2) + (i * stepAngle);
        
        let dist = 0;
        let hitObject = TILES.EMPTY;
        let hitSide = 0; // 0 for dark, 1 for light
        
        // Simple DDA or Step Algorithm
        let rayX = AppState.player.x;
        let rayY = AppState.player.y;
        let sin = Math.sin(rayAngle);
        let cos = Math.cos(rayAngle);
        const stepSize = 0.05;
        
        // Max Draw Distance
        const maxDist = 20.0;
        
        while(dist < maxDist) {
            dist += stepSize;
            rayX += cos * stepSize;
            rayY += sin * stepSize;
            
            const mx = Math.floor(rayX);
            const my = Math.floor(rayY);
            
            if(mx < 0 || mx >= AppState.mapSize || my < 0 || my >= AppState.mapSize) {
                hitObject = TILES.WALL;
                break;
            }
            
            const tile = AppState.map[my][mx];
            
            // What blocks vision? Walls, Secret Walls, Doors
            if(tile === TILES.WALL || tile === TILES.SECRET_WALL || (tile >= TILES.DOOR_1 && tile <= TILES.DOOR_3)) {
                hitObject = tile;
                break;
            }
        }
        
        // Fix Fish-eye
        const correctedDist = dist * Math.cos(rayAngle - AppState.player.dir);
        
        // Height of line
        const wallHeight = Math.min(h, (h / correctedDist));
        
        // Color Determination
        let color = { r:100, g:100, b:100 };
        
        if (WALL_COLORS[hitObject]) {
            color = WALL_COLORS[hitObject];
        } else if (hitObject === TILES.SECRET_WALL) {
             color = WALL_COLORS[TILES.WALL]; // Secret wall logic
        }

        // Shading/Fog
        const brightness = Math.max(0.1, 1.0 - (dist / maxDist));
        const finalColor = `rgb(${color.r * brightness}, ${color.g * brightness}, ${color.b * brightness})`;
        
        // Draw Strip
        ctx.fillStyle = finalColor;
        // Optimization: Draw wider strips
        ctx.fillRect(i*2, (h/2) - (wallHeight/2), 2, wallHeight);
    }
    
    // Draw Objects (Sprite Billboarding - Simplified)
    // For now, simpler approach: just Draw Sprites if very close in 2D? 
    // No, standard raycasters need sprite sorting. 
    // We will do a simpler hack: If player is on top of item, he picks it up.
    // We only need to render items in 3D if we want to see them from afar.
    // For a 6yo's game on Canvas, let's keep it simple: 
    // If an item is in a cell, maybe draw a simple floating icon in 3D?
    // (Omitted for brevity in this step, can be added if requested)
    
    renderParticles(ctx, w, h);
    
    // Mini-map update
    if(AppState.inventory.map) renderMinimap();
}

// Visual Effects
let particles = [];
function createParticles(x, y) {
    // Generate particles
    for(let i=0; i<30; i++) {
        particles.push({
           x: (Math.random() * 800), // Screen space fake mapping for now or 3D?
           // Actually, let's just make them pop in center of screen since we break what's in front
           screenX: 320 + (Math.random()-0.5)*100,
           screenY: 240 + (Math.random()-0.5)*100,
           vx: (Math.random()-0.5) * 10,
           vy: (Math.random()-0.5) * 10,
           life: 1.0,
           color: '#aaaaaa'
        });
    }
}
function renderParticles(ctx, w, h) {
    for(let i=particles.length-1; i>=0; i--) {
        const p = particles[i];
        ctx.fillStyle = `rgba(200,200,200,${p.life})`;
        ctx.fillRect(p.screenX, p.screenY, 5, 5);
        p.screenX += p.vx;
        p.screenY += p.vy;
        p.life -= 0.05;
        if(p.life <= 0) particles.splice(i, 1);
    }
}

function renderMinimap() {
    const c = document.getElementById('minimap');
    const ctx = c.getContext('2d');
    // ... Simplified top-down view ...
    ctx.clearRect(0,0,c.width,c.height);
    
    // Show partial area around player
    const viewSize = 10;
    const cellSize = c.width / viewSize;
    
    const startX = AppState.player.x - viewSize/2;
    const startY = AppState.player.y - viewSize/2;
    
    for(let y=0; y<viewSize; y++) {
        for(let x=0; x<viewSize; x++) {
            const mx = Math.floor(startX + x);
            const my = Math.floor(startY + y);
            
            if(mx>=0 && mx<AppState.mapSize && my>=0 && my<AppState.mapSize) {
                const tile = AppState.map[my][mx];
                ctx.fillStyle = TILE_COLORS[tile] || '#000';
                ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
            }
        }
    }
    
    // Player
    ctx.fillStyle = 'red';
    ctx.beginPath();
    const cx = (viewSize/2) * cellSize;
    const cy = (viewSize/2) * cellSize;
    ctx.arc(cx, cy, 4, 0, Math.PI*2);
    ctx.fill();
    
    // Direction Line
    ctx.strokeStyle = 'white';
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(AppState.player.dir)*10, cy + Math.sin(AppState.player.dir)*10);
    ctx.stroke();
}

function showNotification(text) {
    const el = document.getElementById('message-overlay');
    el.innerText = text;
    el.style.opacity = 1;
    el.style.transform = "translate(-50%, -50%) scale(1.2)";
    setTimeout(() => {
        el.style.opacity = 0;
        el.style.transform = "translate(-50%, -50%) scale(1)";
    }, 2000);
}

// Start
init();

</script>
</body>
</html>
